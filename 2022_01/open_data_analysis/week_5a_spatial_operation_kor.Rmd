---
title: "Spatial_and_Geometry_operation"
author: "Jiho Yeo"
date: "3/31/2022"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 필수 조건

- 이 장에서는 다음 패키지를 설치하고 첨부해야 합니다.

```{r, message=FALSE}
library(sf)
library(dplyr)
library(stringr) # for working with strings (pattern matching)
library(tidyr)   # for unite() and separate()
library(spData)
library(spDataLarge)
```

## 벡터 데이터 {#spacial-vec}에 대한 공간 작업

이 절에서는 **sf** 패키지에서 단순 기능으로 표현되는 벡터 지리 데이터에 대한 공간 작업에 대한 개요를 제공합니다.

### 공간 부분 집합 설정

공간 부분 집합화(spacial subseting)는 공간 객체의 특징을 선택하는 과정이다.

이것은 *속성 부분 집합화*(섹션 \@ref(벡터-속성-부분 집합)와 유사하며, 기본 R 대괄호('[') 연산자를 사용하거나 **tidyvers*\index{tidyvers(패키지)}의 'filter()' 함수를 사용하여 수행할 수 있다.

공간 하위 집합의 예는 **spData*의 'nz' 및 'nz_height' 데이터 세트에 의해 제공된다.

여기에는 뉴질랜드의 16개 주요 지역과 101개 가장 높은 지점에 대한 예측 데이터가 포함되어 있습니다.

다음 코드 청크는 먼저 캔터베리를 나타내는 객체를 만든 다음 공간 하위 집합을 사용하여 영역의 모든 고점을 반환합니다.

```{r}
# 간단한 데이터 설명
# 뉴질랜드 지역의 16개 지역과 101개의 높은 지점을 나타내는 Spatial data
nz
data(nz)
nz_height
data(nz_height)

class(nz)
class(nz_height)

plot(nz[1], reset = FALSE)
plot(nz_height[2], add=TRUE)
```

```{r 04-spatial-operations-3}
# 16개의 main regions
canterbury <-  nz %>% filter(Name == "Canterbury")

# 101개의 highest points
canterbury_height <-  nz_height[canterbury, ]
```

```{r}
# install.packages("tmap")
library(tmap)
tmap_mode("plot")
# tmap_mode("view")


p_hpnz1 = tm_shape(nz) + tm_polygons(col = "white") +
  tm_shape(nz_height) + tm_symbols(shape = 2, col = "red", size = 0.25) +
  tm_layout(main.title = "High points in New Zealand", main.title.size = 1,
            bg.color = "lightblue")

# gray부분으로 칠해진 곳만 추출되었음
p_hpnz2 = tm_shape(nz) + 
  tm_polygons(col = "white") +
  tm_shape(canterbury) + 
  tm_fill(col = "gray") + 
  tm_shape(canterbury_height) + 
  tm_symbols(shape = 2, col = "red", size = 0.25) +
  tm_layout(main.title = "High points in Canterbury", 
            main.title.size = 1,
            bg.color = "lightblue")

tmap_arrange(p_hpnz1, p_hpnz2, ncol = 1) #그래프를 아래로 붙여줌
```

한 *target* `x`*source* 개체 `y`의 내용을 이용해서의 특성 subsetting `x[y,]` 하위 집합 특징처럼.
공간 subsetting 대신 `y` 수업 `logical` 또는 `integer`의---의 `TRUE`과`FALSE` 값 또는 전체 수의 벡터-그것이 또 다른 공간(`sf`)개체입니다.

다양한*topological relations* 공간 subsetting에 쓰일 수 있습니다.
이 건축 공간 관계의 대상 개체의 특징, 그 토대 타입은 subsetting 개체 선택할 수 있는 *touches*, *crosses* 또는*within*(섹션)@ 심판(topological-relations 보))등이 있어야 한다를 결정한다. 
*touches*, *crosses*과*is within* 포함 *Intersects*은 기본 공간subsetting 사업자인 수익 공간의 관계의 많은 유형에 대해 `TRUE` 기본이다.

이 대체 공간 운영자들은`op =` 주장,`sf` 개체에 대한`-LSB-`연산자에 전달할 수 있는 세번째 논쟁으로 지정할 수 있다.
이것은 `st_intersects()`의 반대를 반환합니다 다음과 같은 명령, 캔터베리와 교차하지 않는 경우 포인트(섹션)@ 심판(topological-relations 보))에:증명된다.

```{r 04-spatial-operations-4, eval=FALSE}
#disjoint = canterbury에 속해있지 않은 부분 
nz_height[canterbury, , op = st_disjoint]

# 여기서 비어있는 `, ,`부분은 컬럼을 의미함. 비어놓을 경우 모든 컬럼을 다 가져옴
names(nz_height)
nz_height[canterbury, 2, op = st_disjoint]
```

많은 응용 프로그램에서 벡터 데이터의 공간 부분 집합화에 대해 알아야 할 것은 이것뿐입니다.
이 경우 섹션 \@ref(위상 관계)로 건너뛸 수 있습니다.

다른 부분 집합화 방법을 포함한 세부 사항에 관심이 있으면 계속 읽어 보십시오.
공간 부분 집합을 수행하는 또 다른 방법은 *위상 연산자*가 반환하는 개체를 사용합니다.
이는 아래의 첫 번째 명령에서 확인할 수 있습니다.

```{r}
# 두 공간정보의 공통된 부분을 가져오고 싶을 때
sel_sgbp = st_intersects(x = nz_height, y = canterbury)
class(sel_sgbp)

# 겹치는 부분은 1이다. 따라서 1 이상인 곳들을 뽑는다
sel_logical = lengths(sel_sgbp) > 0
canterbury_height2 = nz_height[sel_logical, ]
#반대
# canterbury_height2 = nz_height[!sel_logical, ]

```

위의 코드 청크에서 클래스 'sgbp'(희소 기하학 이진 술어, 공간 연산에서 길이 'x'의 목록)의 객체가 생성된 다음 논리적 벡터 'sel_logical'('TRUE'와 'FALSE' 값만 포함)로 변환된다.
\index{유사 술어|{위상관계} 참조
함수 'lengths()는 'nz_height'의 어떤 형상이 'y'의 *any* 객체와 교차하는지 식별한다.
이 경우 1은 가능한 최대 값이지만 더 복잡한 연산의 경우, 예를 들어 소스 객체의 두 개 이상의 피쳐와 교차하는 피쳐만 부분 집합화하는 방법을 사용할 수 있다.

논리는 다음과 같이 "filter"와 함께 사용될 수 있음에 유의해야 한다. ('filter = FALSE'는 \@ref(위상관계) 절에서 설명된다.)

````{r}
canterbury_height3 = nz_height %>%
  filter(st_intersects(x = ., y = canterbury, sparse = FALSE))
# x = . : nz_height %>% 를 사용하여 생략가능.
# sparse = FALSE : 바로 TRUE,FALSE 형태가 나옴
```

이 시점에서 공간 하위 집합으로 직접 만들고 중간 선택 개체를 통해 나머지 두 버전을 만드는 'cantterbury_height'의 세 가지 버전이 있다.
이러한 개체와 공간 하위 집합을 보다 자세히 탐색하려면 https://geocompr.github.io/geocompkg/articles/) 및 [version-develops]에 있는 추가 정보를 참조하십시오.

### 공간 결합 

두 개의 비공간 데이터 세트를 결합하려면 섹션 \@ref(벡터 속성 결합)에 설명된 대로 공유 '키' 변수에 의존한다.

공간 데이터 결합은 동일한 개념을 적용하지만 대신 지리적 공간의 공유 영역(공간 오버레이라고도 함)에 의존한다.
속성 데이터와 마찬가지로 결합은 소스 객체('y')에서 대상 객체(결합 함수의 인수 'x')에 새로운 열을 추가한다.

이 과정은 예를 들어 설명할 수 있다.
여러분이 지구 표면에 무작위로 10개의 점들이 분포되어 있다고 상상해 보세요.
육지에 있는 지점들 중, 어느 나라에 있나요?
공간 결합을 입증하기 위한 임의의 점은 다음과 같이 생성된다.

```{r 04-spatial-operations-19}
set.seed(2018) # set seed for reproducibility
data(world)

plot(world[1], col="grey")

(bb_world = st_bbox(world)) # the world's bounds

random_df = tibble(
  x = runif(n = 10, min = bb_world[1], max = bb_world[3]),
  y = runif(n = 10, min = bb_world[2], max = bb_world[4])
)

random_points = random_df %>% 
  st_as_sf(coords = c("x", "y")) %>% # set coordinates
  st_set_crs(4326) # set geographic CRS

plot(world[1],reset=FALSE, col="grey")
plot(random_points,add=TRUE,col="red",cex=1)
```

시나리오는 그림 \@ref(그림:spacial-join)에 나와 있습니다.
random_points 객체(왼쪽 위)에는 속성 데이터가 없는 반면 world(오른쪽 위)에는 속성 데이터가 있습니다.

공간 결합 연산은 'st_join()에 의해 수행되며, 이는 'name_long' 변수를 포인트에 추가함으로써 그림 \@ref(그림:spacial-join)(왼쪽 하단 --- 참조)에 표시된 'random_join'을 생성한다.R'](https://github.com/Robinlovelace/geocompr/blob/master/code/04-spatial-join.R))의.

조인된 데이터 세트를 만들기 전에 공간 하위 집합을 사용하여 랜덤 점만 포함하는 'world_random'을 생성하여 조인된 데이터 세트에 반환된 국가 이름 수가 4개인지 확인합니다(그림 \@ref(그림:spacial-join)의 오른쪽 상단 패널 참조).

```{r 04-spatial-operations-20, message=FALSE}
# random points가 위치한 국가만 가지고옴
world_random = world[random_points, ]
nrow(world_random)

# 시각화
plot(world[1],col="grey",reset=FALSE)
plot(world_random,add=TRUE,col="red")

# 현재 Random points는 어떠한 속성도 가지고 있지 않음
# st_join은 random_points에 world object에 있는 속성을 붙여줌 
random_joined = st_join(random_points, world["name_long"])

random_joined

# left=FALSE 명령어를 쓸 경우 join이 성공한 row만을 남겨줌
random_joined = st_join(random_points, world["name_long"],left = FALSE)
random_joined
```

기본적으로 'st_parament'는 왼쪽 조인을 수행하지만(섹션 \@ref(section \@ref-parament-parament) 참조), 'left = FALSE' 인수를 설정하여 내부 조인을 수행할 수도 있습니다.

공간 부분 집합과 마찬가지로, 'st_join()이 사용하는 기본 위상 연산자는 'st_inters() rocked'이다.

이것은 "join" 인수로 변경할 수 있습니다(자세한 내용은 "?st_join" 참조).
위의 예에서는 점 도면층에 폴리곤 도면층의 피쳐를 추가했습니다.
다른 경우에는 점 특성을 폴리곤 도면층에 결합할 수 있습니다.
두 개 이상의 점이 한 폴리곤 안에 포함되는 경우가 있을 수 있습니다. 
이러한 경우 'st_join()'은 폴리곤 피쳐를 복제합니다. 즉, 각 일치 항목에 대해 새 행을 생성합니다.

### 겹치지 않는 조인

때때로 두 개의 지리적 데이터 세트는 접촉하지 않지만 결합을 가능하게 하는 강력한 지리적 관계를 가지고 있다.

**spData* 패키지에 이미 첨부되어 있는 데이터 세트 'cycle_hire'와 'cycle_hire_osm'이 좋은 예이다.

그림 \@ref(fig:cycle-hire)와 같이 이들을 표시하면 서로 밀접한 관련이 있지만 접촉하지는 않는다는 것을 알 수 있으며, 아래의 코드를 사용하여 기본 버전이 생성됩니다.
\index{discripts! 비중첩}

```{r 04-spatial-operations-21, eval=FALSE}
plot(st_geometry(cycle_hire), col = "blue")
plot(st_geometry(cycle_hire_osm), add = TRUE, pch = 3, col = "red")
```

우리는 어떤 점이 아래와 같이 같은 'st_intersects()'인지 확인할 수 있다.

```{r 04-spatial-operations-22, message=FALSE}
# blue와 red point중에 서로 겹치는 point가 없음
# 여기서 point와 point가 겹친다는 것은, 두 점이 정확하게 일치하는 것을 의미
any(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))

st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE) %>% sum()
```

```{r 04-spatial-operations-23, echo=FALSE, eval=FALSE}
# included to show alternative ways of showing there's no overlap
sum(st_geometry(cycle_hire) %in% st_geometry(cycle_hire_osm))
sum(st_coordinates(cycle_hire)[, 1] %in% st_coordinates(cycle_hire_osm)[, 1])
```

```{r}
library(leaflet)

leaflet() %>%
  # addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>%
  addCircles(data = cycle_hire) %>%
  addCircles(data = cycle_hire_osm, col = "red")  
```

cycle_hire_osm의 capacity 변수를 cycle_hire에 포함된 공식적인 target 데이터에 결합해야 한다고 가정해 보자.
겹치지 않는 조인(join)이 필요한 경우입니다.

```{r}
names(cycle_hire)
names(cycle_hire_osm)
```

가장 간단한 방법은 20m의 임계값 거리를 사용하여 섹션 \@ref(위상 관계)에 표시된 위상 연산자 'st_is_within_distance()'를 사용하는 것이다.

이 관계를 수행하기 전에 두 개체는 투영된 CRS로 변환됩니다.

이러한 투영 객체는 아래에 생성된다(접사 '_P'는 투영 객체의 줄임말이다).

```{r 04-spatial-operations-24}
# 위경도 좌표계이기 때문에 Projected CRS로 변환해줘야함 
# 좌표계 단위가 도(degree)에서 meter로 변환됨

# 좌표계 보기
data(cycle_hire_osm)
data(cycle_hire)

cycle_hire %>% st_crs()
cycle_hire_osm %>% st_crs()

# 좌표계 변환
cycle_hire_P = st_transform(cycle_hire, 27700)
cycle_hire_osm_P = st_transform(cycle_hire_osm, 27700)

# 20m 내에 있는 point들을 join 시킴
sel = st_is_within_distance(cycle_hire_P, cycle_hire_osm_P, dist = 20)
summary(lengths(sel) > 0)
```

이는 대상 객체 cycle_hire_osm_P의 임계값 거리 내에 'rsum(lengths(sel) > 0)' 점이 있음을 보여준다.
각 'cycle_hire_osm_'과 관련된 *값*을 검색하는 방법무슨 소리죠? 들려요?

해결책은 다시 'st_join()을 사용하지만 추가 'dist' 인수를 사용한다(아래 20m로 설정).

```{r 04-spatial-operations-25}
# st_join 명령어에서 dist argument를 넣어줌
z = st_join(cycle_hire_P, cycle_hire_osm_P,
            join = st_is_within_distance, dist = 20)

# 행의수가 증가하였음
# cycle_hire_P와 cycle_hire_osm_P 간에 여러개가 매칭된 경우가 발생
nrow(cycle_hire)
nrow(z)
```

조인된 결과의 행 수가 목표값보다 큽니다.
cycle_hire_P의 일부 사이클 대여 스테이션에서 cycle_hire_osm_P의 일치가 여러 개 있기 때문이다.

중복되는 점의 값을 집계하고 평균을 반환하기 위해 \@ref(attr) 장에서 학습한 집계 방법을 사용하면 대상과 같은 수의 행이 있는 개체를 만들 수 있다.

```{r 04-spatial-operations-26}
z = z %>% 
  group_by(id) %>% 
  summarize(capacity = mean(capacity))

nrow(z) == nrow(cycle_hire)
```

인근 스테이션의 용량은 소스 'cycle_hire_osm' 데이터의 용량 그림과 이 새 개체의 결과를 비교하여 확인할 수 있습니다(그림은 표시되지 않음).

```{r 04-spatial-operations-27, eval=FALSE}
plot(cycle_hire_osm["capacity"])
plot(z["capacity"])
```

이 결합의 결과는 공간 연산을 사용하여 단순 형상과 관련된 속성 데이터를 변경했으며, 각 형상과 관련된 형상은 변경되지 않았다.

### 공간 데이터 집계 {#spacial-aggr}

섹션 \@ref(벡터-속성-집약)에서 다루는 속성 데이터 집합과 마찬가지로 공간 데이터 집합은 데이터를 *축소*하는 방법이 될 수 있다.

집계된 데이터는 특정 종류의 *그룹화 변수*와 관련된 변수(일반적으로 평균 또는 총)에 대한 일부 통계량을 보여 줍니다.
섹션 \@ref(vector-attribute-aggregation)는 'aggregate() 및 'group_by() %>% summarize()' 데이터를 속성 변수를 기반으로 어떻게 축약하는지를 보여주었다.
이 섹션에서는 공간 그룹화 변수를 사용하여 동일한 기능이 작동하는 방식을 설명합니다.

뉴질랜드의 예로 돌아가면, 각 지역의 평균 고점 높이를 알아보려고 합니다.
이것은 공간 집계의 좋은 예이다: 대상 객체의 값('x' 또는 'nz_height')이 그룹화되는 방식을 정의하는 소스(이 경우 'y' 또는 'nz')의 기하학이다.
이는 아래의 기본 'aggregate() 함수'를 사용하여 설명된다.

```{r 04-spatial-operations-28}
# 101개의 point 데이터, 뉴질랜드에서의 높은 지역
plot(nz[1],reset=FALSE,col="grey")
plot(nz_height[1], add=TRUE)

names(nz_height)
nrow(nz_height)


nz_avheight = aggregate(x = nz_height, by = nz, FUN = mean)
```

tidy 함수 group_by()와 summarize()를 사용하여 동일한 결과를 생성할 수도 있다.

```{r}
library(tmap)

tm_shape(nz_avheight) +
  tm_fill("elevation", breaks = seq(27, 30, by = 0.5) * 1e2) +
  tm_borders()
```

```{r 04-spatial-operations-29}
# aggregate 함수 대신 st_join 함수를 써도 똑같이 할 수 있음
nz_avheight2 = nz %>%
  st_join(nz_height) %>%
  group_by(Name) %>%
  summarize(elevation = mean(elevation, na.rm = TRUE))
```

결과 "nz_avheight" 객체는 집계 객체 "nz"와 동일한 형상을 가지지만 뉴질랜드의 각 영역 내의 점들의 평균 높이를 나타내는 새로운 열을 가진다('median()과 'sd()'와 같은 다른 요약 함수를 mean() 대신 사용할 수 있다.
점을 포함하지 않는 영역에는 연관된 '상승' 값이 'NA'라는 점에 유의한다.
새 지오메트리를 생성하는 집계 연산은 섹션 \@ref(기하-연합)를 참조하십시오.


### 거리 관계 

위상 관계는 이항 관계인 반면 - 피쳐는 다른 피쳐와 교차하거나 교차하지 않습니다 - 거리 관계는 연속적입니다.

두 물체 사이의 거리는 'st_distance()' 함수로 계산된다.

이는 뉴질랜드에서 가장 높은 지점과 캔터베리 지역의 지리적 중심 사이의 거리를 찾는 아래의 코드 청크에 나타나 있다.
\index{discription!거리 관계}

```{r}
# topological relation은 binary 형태로 표현됨
# 예를들어, 두 geometry 데이터가 겹친다 혹은 안겹친다, 이런식으로 표현됨
# 하지만 두 geometry 사이의 거리는 binary가 아니라 continuous한 형태임
# st_distance() 명령어를 통해 두 objects 사이의 거리 계산이 가능

# 뉴질랜드에서 가장 높은 point 추출
nz_heighest = nz_height %>% top_n(n = 1, wt = elevation)

# cantebury 지역의 centroid 좌표 추출
canterbury = nz %>% filter(Name == "Canterbury")
canterbury_centroid = st_centroid(canterbury)

# 두 점 사이의 거리 계산
st_distance(nz_heighest, canterbury_centroid)
```

이 결과에 대해 두 가지 잠재적으로 놀라운 사실이 있습니다.

- 거리는 10만 인치가 아닌 10만 미터 또는 기타 거리 측정 단위인 '단위'를 가지고 있습니다.

- 결과가 단일 값만 포함하더라도 행렬로 반환됩니다.

이 두 번째 기능은 객체 'x'와 'y'의 모든 기능 조합 간에 *거리 행렬*을 반환하는 기능을 제공하는 'st_distance()의 또 다른 유용한 기능을 암시한다.

이는 nz_height의 처음 세 형상과 객체 co로 대표되는 뉴질랜드의 오타고 및 캔터베리 지역 사이의 거리를 찾는 아래 명령어에 나와 있다.

```{r 04-spatial-operations-32}
# 여러개의 points들 사이의 거리 계산이 가능

co = filter(nz, grepl("Canter|Otag", Name))
st_distance(nz_height[1:3, ], co)
```

nz_height의 두 번째 피처와 세 번째 피처와 co의 두 번째 피처 사이의 거리는 0이다.

이는 점과 다각형 사이의 거리가 *다각형 중 임의의 부분*까지의 거리를 의미한다는 사실을 보여준다.
nz_height의 두 번째와 세 번째 포인트는 *in* Otago이며, 이 포인트는 그림으로 확인할 수 있습니다(결과는 표시되지 않음).

```{r 04-spatial-operations-33, eval=FALSE}
# st_distance 명령어를 point와 polygon 대상으로 했을 때는, point가 polygon 안에 들어 있으면, distance를 0으로 계산함
plot(st_geometry(co)[2])
plot(st_geometry(nz_height)[2:3], add = TRUE)
```


