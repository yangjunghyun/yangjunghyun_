```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Prerequisites

- This chapter requires the following packages to be installed and attached: 

```{r, message=FALSE}
library(sf)
library(dplyr)
library(stringr) # for working with strings (pattern matching)
library(tidyr)   # for unite() and separate()
library(spData)
library(spDataLarge)
```

## Spatial operations on vector data {#spatial-vec}

This section provides an overview of spatial operations on vector geographic data represented as simple features in the **sf** package.

### Spatial subsetting

Spatial subsetting is the process of selecting features of a spatial object based on whether or not they in some way *relate* in space to another object.

It is analogous to *attribute subsetting* (covered in Section \@ref(vector-attribute-subsetting)) and can be done with the base R square bracket (`[`) operator or with the `filter()` function from the **tidyverse**\index{tidyverse (package)}.

An example of spatial subsetting is provided by the `nz` and `nz_height` datasets in **spData**.

These contain projected data on the 16 main regions and 101 highest points in New Zealand, respectively.

The following code chunk first creates an object representing Canterbury, then uses spatial subsetting to return all high points in the region:

```{r}
# 간단한 데이터 설명
# 뉴질랜드 지역의 16개 지역과 101개의 높은 지점을 나타내는 Spatial data

data(nz)
nz_height
data(nz_height)

class(nz)
class(nz_height)

plot(nz[1], reset = FALSE)
plot(nz_height[2], add=TRUE)
```

```{r 04-spatial-operations-3}
# 16개의 main regions
canterbury = nz %>% filter(Name == "Canterbury")

# 101개의 highest points
canterbury_height = nz_height[canterbury, ]
```

```{r}
# install.packages("tmap")
library(tmap)
tmap_mode("plot")
# tmap_mode("view")

p_hpnz1 = tm_shape(nz) + tm_polygons(col = "white") +
  tm_shape(nz_height) + tm_symbols(shape = 2, col = "red", size = 0.25) +
  tm_layout(main.title = "High points in New Zealand", main.title.size = 1,
            bg.color = "lightblue")

p_hpnz2 = tm_shape(nz) + 
  tm_polygons(col = "white") +
  tm_shape(canterbury) + 
  tm_fill(col = "gray") + 
  tm_shape(canterbury_height) + 
  tm_symbols(shape = 2, col = "red", size = 0.25) +
  tm_layout(main.title = "High points in Canterbury", 
            main.title.size = 1,
            bg.color = "lightblue")

tmap_arrange(p_hpnz1, p_hpnz2, ncol = 1)
```

Like attribute subsetting `x[y, ]` subsets features of a *target* `x` using the contents of a *source* object `y`.
Instead of `y` being of class `logical` or `integer` --- a vector of `TRUE` and `FALSE` values or whole numbers --- for spatial subsetting it is another spatial (`sf`) object.

Various *topological relations* can be used for spatial subsetting.
These determine the type of spatial relationship that features in the target object must have with the subsetting object to be selected, including *touches*, *crosses* or *within* (see Section \@ref(topological-relations)). 
*Intersects* is the default spatial subsetting operator, a default that returns `TRUE` for many types of spatial relations, including *touches*, *crosses* and *is within*.

These alternative spatial operators can be specified with the `op =` argument, a third argument that can be passed to the `[` operator for `sf` objects.
This is demonstrated in the following command which returns the opposite of `st_intersects()`, points that do not intersect with Canterbury (see Section \@ref(topological-relations)):

```{r 04-spatial-operations-4, eval=FALSE}
nz_height[canterbury, , op = st_disjoint]

# 여기서 비어있는 `, ,`부분은 컬럼을 의미함. 비어놓을 경우 모든 컬럼을 다 가져옴
names(nz_height)
nz_height[canterbury, 2, op = st_disjoint]
```

For many applications, this is all you'll need to know about spatial subsetting for vector data.
In this case, you can safely skip to Section \@ref(topological-relations).

If you're interested in the details, including other ways of subsetting, read on.
Another way of doing spatial subsetting uses objects returned by *topological operators*.
This is demonstrated in the first command below:

```{r}
sel_sgbp = st_intersects(x = nz_height, y = canterbury)
class(sel_sgbp)

sel_logical = lengths(sel_sgbp) > 0
canterbury_height2 = nz_height[sel_logical, ]
```

In the above code chunk, an object of class `sgbp` (a sparse geometry binary predicate, a list of length `x` in the spatial operation) is created and then converted into a logical vector `sel_logical` (containing only `TRUE` and `FALSE` values).
\index{binary predicate|seealso {topological relations}}
The function `lengths()` identifies which features in `nz_height` intersect with *any* objects in `y`.
In this case 1 is the greatest possible value but for more complex operations one could use the method to subset only features that intersect with, for example, 2 or more features from the source object.

It should be noted that a logical  can also be used with `filter()` as follows (`sparse = FALSE` is explained in Section \@ref(topological-relations)):

````{r}
canterbury_height3 = nz_height %>%
  filter(st_intersects(x = ., y = canterbury, sparse = FALSE))
```

At this point, there are three versions of `canterbury_height`, one created with spatial subsetting directly and the other two via intermediary selection objects.
To explore these objects and spatial subsetting in more detail, see the supplementary vignettes on `subsetting` and [`tidyverse-pitfalls`](https://geocompr.github.io/geocompkg/articles/).

### Spatial joining 

Joining two non-spatial datasets relies on a shared 'key' variable, as described in Section \@ref(vector-attribute-joining).

Spatial data joining applies the same concept, but instead relies on shared areas of geographic space (it is also know as spatial overlay).
As with attribute data, joining adds a new column to the target object (the argument `x` in joining functions), from a source object (`y`).

The process can be illustrated by an example.
Imagine you have ten points randomly distributed across the Earth's surface.
Of the points that are on land, which countries are they in?
Random points to demonstrate spatial joining are created as follows:

```{r 04-spatial-operations-19}
set.seed(2018) # set seed for reproducibility
data(world)

plot(world[1], col="grey")

(bb_world = st_bbox(world)) # the world's bounds

random_df = tibble(
  x = runif(n = 10, min = bb_world[1], max = bb_world[3]),
  y = runif(n = 10, min = bb_world[2], max = bb_world[4])
)

random_points = random_df %>% 
  st_as_sf(coords = c("x", "y")) %>% # set coordinates
  st_set_crs(4326) # set geographic CRS

plot(world[1],reset=FALSE, col="grey")
plot(random_points,add=TRUE,col="red",cex=1)
```

The scenario is illustrated in Figure \@ref(fig:spatial-join).
The `random_points` object (top left) has no attribute data, while the `world` (top right) does.

The spatial join operation is done by `st_join()`, which adds the `name_long` variable to the points, resulting in `random_joined` which is illustrated in Figure \@ref(fig:spatial-join) (bottom left --- see [`04-spatial-join.R`](https://github.com/Robinlovelace/geocompr/blob/master/code/04-spatial-join.R)).

Before creating the joined dataset, we use spatial subsetting to create `world_random`, which contains only countries that contain random points, to verify the number of country names returned in the joined dataset should be four (see the top right panel of Figure \@ref(fig:spatial-join)).

```{r 04-spatial-operations-20, message=FALSE}
# random points가 위치한 국가만 가지고옴
world_random = world[random_points, ]
nrow(world_random)

# 시각화
plot(world[1],col="grey",reset=FALSE)
plot(world_random,add=TRUE,col="red")

# 현재 Random points는 어떠한 속성도 가지고 있지 않음
# st_join은 random_points에 world object에 있는 속성을 붙여줌 
random_joined = st_join(random_points, world["name_long"])

random_joined

# left=FALSE 명령어를 쓸 경우 join이 성공한 row만을 남겨줌
random_joined = st_join(random_points, world["name_long"],left = FALSE)
random_joined
```

By default, `st_join()` performs a left join (see Section \@ref(vector-attribute-joining)), but it can also do inner joins by setting the argument `left = FALSE`.

Like spatial subsetting, the default topological operator used by `st_join()` is `st_intersects()`.

This can be changed with the `join` argument (see `?st_join` for details).
In the example above, we have added features of a polygon layer to a point layer.
In other cases, we might want to join point attributes to a polygon layer.
There might be occasions where more than one point falls inside one polygon. 
In such a case `st_join()` duplicates the polygon feature: it creates a new row for each match.

### Non-overlapping joins

Sometimes two geographic datasets do not touch but still have a strong geographic relationship enabling joins.

The datasets `cycle_hire` and `cycle_hire_osm`, already attached in the **spData** package, provide a good example.

Plotting them shows that they are often closely related but they do not touch, as shown in Figure \@ref(fig:cycle-hire), a base version of which is created with the following code below:
\index{join!non-overlapping}

```{r 04-spatial-operations-21, eval=FALSE}
plot(st_geometry(cycle_hire), col = "blue")
plot(st_geometry(cycle_hire_osm), add = TRUE, pch = 3, col = "red")
```

We can check if any points are the same `st_intersects()` as shown below:

```{r 04-spatial-operations-22, message=FALSE}
# blue와 red point중에 서로 겹치는 point가 없음
# 여기서 point와 point가 겹친다는 것은, 두 점이 정확하게 일치하는 것을 의미
any(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))

st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE) %>% sum()
```

```{r 04-spatial-operations-23, echo=FALSE, eval=FALSE}
# included to show alternative ways of showing there's no overlap
sum(st_geometry(cycle_hire) %in% st_geometry(cycle_hire_osm))
sum(st_coordinates(cycle_hire)[, 1] %in% st_coordinates(cycle_hire_osm)[, 1])
```

```{r}
library(leaflet)

leaflet() %>%
  # addProviderTiles(providers$OpenStreetMap.BlackAndWhite) %>%
  addCircles(data = cycle_hire) %>%
  addCircles(data = cycle_hire_osm, col = "red")  
```

Imagine that we need to join the `capacity` variable in `cycle_hire_osm` onto the official 'target' data contained in `cycle_hire`.
This is when a non-overlapping join is needed.

```{r}
names(cycle_hire)
names(cycle_hire_osm)
```

The simplest method is to use the topological operator `st_is_within_distance()` shown in Section \@ref(topological-relations), using a threshold distance of 20 m.

Note that, before performing the relation, both objects are transformed into a projected CRS.

These projected objects are created below (note the affix `_P`, short for projected):

```{r 04-spatial-operations-24}
# 위경도 좌표계이기 때문에 Projected CRS로 변환해줘야함 
# 좌표계 단위가 도(degree)에서 meter로 변환됨

# 좌표계 보기
data(cycle_hire_osm)
data(cycle_hire)

cycle_hire %>% st_crs()
cycle_hire_osm %>% st_crs()

# 좌표계 변환
cycle_hire_P = st_transform(cycle_hire, 27700)
cycle_hire_osm_P = st_transform(cycle_hire_osm, 27700)

# 20m 내에 있는 point들을 join 시킴
sel = st_is_within_distance(cycle_hire_P, cycle_hire_osm_P, dist = 20)
summary(lengths(sel) > 0)
```

This shows that there are `r sum(lengths(sel) > 0)` points in the target object `cycle_hire_P` within the threshold distance of `cycle_hire_osm_P`.
How to retrieve the *values* associated with the respective `cycle_hire_osm_P` points?

The solution is again with `st_join()`, but with an addition `dist` argument (set to 20 m below):

```{r 04-spatial-operations-25}
# st_join 명령어에서 dist argument를 넣어줌
z = st_join(cycle_hire_P, cycle_hire_osm_P,
            join = st_is_within_distance, dist = 20)

# 행의수가 증가하였음
# cycle_hire_P와 cycle_hire_osm_P 간에 여러개가 매칭된 경우가 발생
nrow(cycle_hire)
nrow(z)
```

Note that the number of rows in the joined result is greater than the target.
This is because some cycle hire stations in `cycle_hire_P` have multiple matches in `cycle_hire_osm_P`.

To aggregate the values for the overlapping points and return the mean, we can use the aggregation methods learned in Chapter \@ref(attr), resulting in an object with the same number of rows as the target:

```{r 04-spatial-operations-26}
z = z %>% 
  group_by(id) %>% 
  summarize(capacity = mean(capacity))

nrow(z) == nrow(cycle_hire)
```

The capacity of nearby stations can be verified by comparing a plot of the capacity of the source `cycle_hire_osm` data with the results in this new object (plots not shown):

```{r 04-spatial-operations-27, eval=FALSE}
plot(cycle_hire_osm["capacity"])
plot(z["capacity"])
```

The result of this join has used a spatial operation to change the attribute data associated with simple features;  the geometry associated with each feature has remained unchanged.

### Spatial data aggregation {#spatial-aggr}

Like attribute data aggregation, covered in Section \@ref(vector-attribute-aggregation), spatial data aggregation can be a way of *condensing* data.

Aggregated data show some statistics about a variable (typically average or total) in relation to some kind of *grouping variable*.
Section \@ref(vector-attribute-aggregation) demonstrated how `aggregate()` and `group_by() %>% summarize()` condense data based on attribute variables.
This section demonstrates how the same functions work using spatial grouping variables.

Returning to the example of New Zealand, imagine you want to find out the average height of high points in each region.
This is a good example of spatial aggregation: it is the geometry of the source (`y` or `nz` in this case) that defines how values in the target object (`x` or `nz_height`) are grouped.
This is illustrated using the base `aggregate()` function below:

```{r 04-spatial-operations-28}
# 101개의 point 데이터, 뉴질랜드에서의 높은 지역
plot(nz[1],reset=FALSE,col="grey")
plot(nz_height[1], add=TRUE)

names(nz_height)
nrow(nz_height)


nz_avheight = aggregate(x = nz_height, by = nz, FUN = mean)
```

The same result can also be generated using the 'tidy' functions `group_by()` and `summarize()` (used in combination with `st_join()`):

```{r}
library(tmap)

tm_shape(nz_avheight) +
  tm_fill("elevation", breaks = seq(27, 30, by = 0.5) * 1e2) +
  tm_borders()
```

```{r 04-spatial-operations-29}
# aggregate 함수 대신 st_join 함수를 써도 똑같이 할 수 있음
nz_avheight2 = nz %>%
  st_join(nz_height) %>%
  group_by(Name) %>%
  summarize(elevation = mean(elevation, na.rm = TRUE))
```

The resulting `nz_avheight` objects have the same geometry as the aggregating object `nz` but with a new column representing the mean average height of points within each region of New Zealand (other summary functions such as `median()` and `sd()` can be used in place of `mean()`).
Note that regions containing no points have an associated `elevation` value of `NA`.
For aggregating operations which also create new geometries, see Section \@ref(geometry-unions).


### Distance relations 

While topological relations are binary --- a feature either intersects with another or does not --- distance relations are continuous.

The distance between two objects is calculated with the `st_distance()` function.

This is illustrated in the code chunk below, which finds the distance between the highest point in New Zealand and the geographic centroid of the Canterbury region, created in Section \@ref(spatial-subsetting):
\index{sf!distance relations}

```{r}
# topological relation은 binary 형태로 표현됨
# 예를들어, 두 geometry 데이터가 겹친다 혹은 안겹친다, 이런식으로 표현됨
# 하지만 두 geometry 사이의 거리는 binary가 아니라 continuous한 형태임
# st_distance() 명령어를 통해 두 objects 사이의 거리 계산이 가능

# 뉴질랜드에서 가장 높은 point 추출
nz_heighest = nz_height %>% top_n(n = 1, wt = elevation)

# cantebury 지역의 centroid 좌표 추출
canterbury = nz %>% filter(Name == "Canterbury")
canterbury_centroid = st_centroid(canterbury)

# 두 점 사이의 거리 계산
st_distance(nz_heighest, canterbury_centroid)
```

There are two potentially surprising things about the result:

- It has `units`, telling us the distance is 100,000 meters, not 100,000 inches, or any other measure of distance

- It is returned as a matrix, even though the result only contains a single value

This second feature hints at another useful feature of `st_distance()`, its ability to return *distance matrices* between all combinations of features in objects `x` and `y`.

This is illustrated in the command below, which finds the distances between the first three features in `nz_height` and the Otago and Canterbury regions of New Zealand represented by the object `co`.

```{r 04-spatial-operations-32}
# 여러개의 points들 사이의 거리 계산이 가능

co = filter(nz, grepl("Canter|Otag", Name))
st_distance(nz_height[1:3, ], co)
```

Note that the distance between the second and third features in `nz_height` and the second feature in `co` is zero.

This demonstrates the fact that distances between points and polygons refer to the distance to *any part of the polygon*:
The second and third points in `nz_height` are *in* Otago, which can be verified by plotting them (result not shown):

```{r 04-spatial-operations-33, eval=FALSE}
# st_distance 명령어를 point와 polygon 대상으로 했을 때는, point가 polygon 안에 들어 있으면, distance를 0으로 계산함
plot(st_geometry(co)[2])
plot(st_geometry(nz_height)[2:3], add = TRUE)
```


