---
title: "week_2a_Use_tidyverse"
author: "junghyun"
date: '2022 4 15 '
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
rm(list=ls())
```


# 1. Tidyverse 패키지
ggplot2, dplyr, tidyr, readr, purr, tibble, stringr, forcats

```{r}
library(tidyverse)
```
코드가 길어지면 이해하기 어려운 한계가 존재
```{r}
plot(diff(log(sample(rnorm(10000, mean = 10, sd = 1), size = 100, replace = FALSE))),col = "red", type = "l")
```

# 2. 파이프 연산자( %>% )을 통한 코드의 직관화
순차적 흐름으로 코드를 이해할 수 있음
중간 변수들을 계속해서 object로 할당할 필요가 없음


```{r}
rnorm(10000, mean = 10, sd = 1) %>% #정규분포에서 랜덤넘버 10000개 생성
  sample(size = 100, replace =FALSE) %>% 
  log() %>% 
  diff() %>% 
  plot(col = "red",type="l")
```

# 3. Flight 데이터의 파이프 연산자 예시

```{r}
library(nycflights13)

nrow(flights) #행의 수

head(flights)

```

## flights data를 선택 후, group_by 한 후, summarise를 수행

```{r}
flights %>% 
  group_by(year,month,day) %>% 
  summarise(delay = mean(dep_delay, na.rm = TRUE))

mean_dalay_by_day <- flights %>% 
  group_by(year,month,day) %>% 
  summarise(delay = mean(dep_delay, na.rm = TRUE))
```

# 4. dplyr 패키지에 포함된 유용한 명령어들

## 4.1 select() : 열방향 선택

데이터에서 특정 컬럼을 선택하고 싶을 때 사용, 선언된 순서대로 컬럼을 정렬함.

```{r}
flights %>% select(year,month,day)

# (year,month,day)를 제외하고 선택하고 싶을 때
flights %>% select(-(year:day))

# 선언된 순서대로 가져오고 싶을 때
flights %>% select(time_hour, air_time, everything())

# 컬럼에 띄어쓰기가 존재할 때
flights$`not use` <- 0

# 컬럼이름에 되도록 띄어쓰기는 사용X
flights %>% select(`not use`) 

# 제거하고 싶을 때
flights$`not use` <- NULL

```

## 4.2. mutate() : 새로운 컬럼을 만들거나 계산하고 싶을 때

```{r}
#year에서 day까지, delay로 끝나는 컬럼, distance, air_time 선택
flight_sample <- flights %>% select(year:day, ends_with("delay"), distance, air_time)

#start_with() : 특정한 단어로 시작하는 컬럼
flight_sample

#contains(): 특정한 단어가 포함된 컬럼
flights %>% select(contains("time"))

# transmute(): mutate와 동일하지만 기존에 있는 column들을 모두 제거
flights %>% transmute(
  hour = dep_time %/% 100, #몫
  minute = dep_time %% 100) #나머지

```

각 컬럼 간의 계산으로 새로운 열(Column)을 만듬

```{r}
#기존방식
# flight_sample$net_delay <- flight_sample$arr_delay - flight_sampledep_delay

flight_sample %>% mutate(net_delay = arr_delay - dep_delay,
                         speed = distance/air_time*60)

```

## 4.3. filter() : 행방향으로 조건을 설정

filter() 는 데이터 중에 조건에 해당하는 일부 데이터만 필터해서 사용.
논리 연산자와 결합하여 많이 사용.

```{r}
a <- c(10,20,30,40,50)
b <- 30

#논리 연산자
a == b # FALSE FALSE  TRUE FALSE FALSE

a > b #FALSE FALSE FALSE  TRUE  TRUE

# 숫자를 사용한 인덱싱
a[1]
a[c(1,3)] #10 30

# 논리 연산자를 사용한 인덱싱
a[a>b] # 40 50

a[c(4,5)] # 40 50

```

```{r}
flights %>% filter(month==1)

# 1월 또는 2월인 데이터
flights %>% filter(month == 1 | month ==2)
# %in% 또한 가능
flights %>% filter(month %in% c(1,2))
```

## 4.4. bind_rows() : 두 데이터를 행방향으로 묶음
데이터를 아래로 붙임

filter()를 사용한 subset 추출

```{r}
jan <- flights %>% filter(month==1)
feb <- flights %>% filter(month==2)

janfeb <- bind_rows(jan,feb)
janfeb
# 이 코드와 같음
flights %>% filter(month %in% c(1,2))
```

## 4.5.arrange(): 데이터 정렬
지정되는 컬럼 기준으로 오름차순으로 정렬

```{r}
# 오름차순 정렬
flights %>% arrange(dep_delay)

# 내림차순 정렬
flights %>% arrange(-dep_delay)
flights %>% arrange(desc(dep_delay))
```

## 4.6. `group_by()` & `summarise()` : 그룹별로 계산을 수행

그룹별로 통계치를 뽑거나 특정 계산을 수행하고 싶은 경우

```{r}
# Group_by를 하지 않았을 때
flights %>% 
  summarise(mean_dep_delay = mean(dep_delay, na.rm =T),
            count = n())

#group_by
flights %>% 
  group_by(month) %>% 
  summarise(mean_dep_delay = mean(dep_delay, na.rm =T),
            count = n())

# ungroup(): group을 제거하고 싶을 때
flights %>% ungroup()
```

## 4.7. `left_join()`

```{r}
# 특정 컬럼만 추출
flight_sample <- flights %>% select(year:day, origin, carrier)
flight_sample
```

```{r}
airlines
```

두 데이터를 특정한 key value를 기준으로 좌우로 붙이고 싶을 때

```{r}
flight_sample %>% left_join(airlines, by="carrier")
```

key 값의 컬럼 이름이 다를 경우

```{r}
colnames(airlines)[1] <- "company_name"

flight_sample %>% left_join(airlines, by = c("carrier" = "company_name"))
```


## 4.8. rename():컬럼이름을 변경해줌

```{r}
flights %>% rename(tail_num = tailnum)
```


##########03/10##########

# Data transformation
 

### Missing values

Missing value는 항상 젤 밑으로 감 (arrange를 사용하면 가장 아래 위치)


```{r}
x <- NA
is.na(x)

is.na(flights$dep_time)

#NA값 개수
sum(is.na(flights$dep_time))
flights$dep_time %>% is.na() %>% sum()

# na.rm = TRUE : na값을 포함하지 않음
flights %>% 
  group_by(year,month,day) %>% 
  summarise(mean = mean(dep_delay, na.rm = TRUE))

# !is.na() : na가 아닌 값
not_cancelled <- flights %>% filter(!is.na(dep_delay),!is.na(arr_delay))
```

## Grouped mutates

- 년/월/일자별 가장 arr_delay가 높은 10개의 비행만을 추출

```{r}
flights %>% 
  group_by(year,month,day) %>% 
  filter(rank(desc(arr_delay))< 11) %>%  #rank():
  select(year,month,day,arr_delay)

#slice_max() = rank(desc(arr_delay))< 11 : 상위 10개 값만 뽑음
flights %>% 
  group_by(year,month,day) %>% 
  slice_max(arr_delay, n = 10) %>% 
  select(year,month,day, arr_delay)

flights %>% mutate(
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours,
  .after = year
) # .after = 원하는 곳에 data를 추가
```

##########03/15##########

- `dest` (도착공항) 별로 그룹을 해서, 비행기가 10000대 이상 착륙한 공항으로 도착한 비행정보만 추출

```{r}
popular_dests <- flights %>% 
  group_by(dest) %>% 
  filter(n()>10000)

table(popular_dests$dest)
```

```{r}
tmp <- popular_dests %>% 
  filter(arr_delay>0) %>% 
  mutate(prop_delay = arr_delay / sum(arr_delay)) %>% 
  select(year:day, dest, arr_delay, prop_delay)

tmp
```

group_by로 인해 값이 바뀔 수 있음을 주의

```{r}
grade <- tibble(
  name = c("Paul","James","Durant","Harden","Jordan"),
  region = c("west","west","east","east","east"),
  score = c(95,91,87,89,100))

# group_by 하지 않았을 때
score_proportion <- grade %>% 
  mutate(prop_score = score / sum(score))

sum(score_proportion$prop_score)

# group_by를 했을 때
score_proportion <- grade %>% 
  group_by(region) %>% 
  mutate(prop_score = score / sum(score))

sum(score_proportion$prop_score)

```

