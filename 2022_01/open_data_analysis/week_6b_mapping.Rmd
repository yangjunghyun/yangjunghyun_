---
title: "mapping_2"
author: "jiho yeo"
date: "5/28/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Prerequisites {-}

```{r 08-mapping-1, message=FALSE }
library(sf)
library(tidyverse)
library(spData)
library(spDataLarge)
# library(raster)
library(tmap)    # for static and interactive maps
library(leaflet) # for interactive maps
library(ggplot2) # tidyverse data visualization package
```
## 1. 정적 지도

### 레이아웃

지도 레이아웃은 모든 지도 요소를 결합하는 맵으로 조합하는 것입니다.
지도 요소에는 매핑할 객체, 제목, 축척 막대, 여백 및 가로 세로 비율이 포함되며, 이전 섹션에서 설명한 색상 설정은 지도의 모양에 영향을 미치는 데 사용된 팔레트 및 중단점과 관련이 있습니다.
두 가지 모두 지도에서 남긴 인상에 똑같이 큰 영향을 미칠 수 있는 미묘한 변화를 초래할 수 있습니다.


```{r}
map_nz <- tm_shape(nz) + tm_polygons()

# tm_compass 나침반
# tm_scale_bar 척도바
map_nz + 
  tm_compass(type = "8star", position = c("left", "top")) +
  tm_scale_bar(breaks = c(0, 100, 200), text.size = 1)
```

**tmap**은 또한 매우 다양한 레이아웃 설정을 변경할 수 있으며, 그 중 일부는 다음과 같은 코드를 사용하여 생성됩니다(전체 목록은 'args(tm_layout)' 또는 '?tm_layout' 참조).

```{r 08-mapping-14, eval=FALSE}
map_nz + tm_layout(title = "New Zealand")
map_nz + tm_layout(scale = 5)
map_nz + tm_layout(bg.color = "lightblue") #배경 색
map_nz + tm_layout(frame = FALSE) # 그림 테두리 제거
```

'tm_layout()'의 다른 인수는 맵이 위치한 캔버스와 관련하여 맵의 더 많은 측면에 대한 제어를 제공한다.

- 프레임 너비('frame.lwd') 및 이중 라인을 허용하는 옵션('frame.double.line')
- 'outter.margin' 및 'inner.margin'을 포함한 여백 설정
- 'fontface' 및 'fontfamily'에 의해 제어되는 글꼴 설정
- 범례와 같은 이진 옵션을 포함한 범례 설정.show' (범례 표시 여부) 'marget.only'(지도 표시) 및 'marget'입니다.outside(범례가 지도 밖으로 나와야 합니까?)는 물론, 'model.position'과 같은 다중 선택 설정입니다.
- 에스테틱 레이어의 기본 색상('aes.color'), 프레임과 같은 지도 속성('attr.color')
- '세피아'를 제어하는 색 설정입니다.강도(지도의 노란색 표시) 및 포화(색-회색 눈금)

```{r}
legend_title = expression("Area (km"^2*")")

map_nza = tm_shape(nz) +
  tm_fill(col = "Land_area", title = legend_title) + tm_borders()

c1 = map_nza + tm_layout('frame.lwd = 5', frame.lwd = 5) 
c2 = map_nza + tm_layout('inner.margins = 0.2', inner.margins = 0.2)
c3 = map_nza + tm_layout('legend.show = FALSE', legend.show = FALSE)
c4 = map_nza + tm_layout('legend.position =\n c("right", "bottom")', 
                         legend.position = c("right", "bottom"))

tmap_arrange(c1, c2, c3, c4, nrow = 1)
```

위에 나열된 색상 설정 변경의 영향은 그림 \@ref(그림:layout3)에 나와 있습니다(전체 목록은 '?tm_layout' 참조).

```{r}
legend_title = expression("Area (km"^2*")")

map_nza = tm_shape(nz) +
  tm_fill(col = "Land_area", title = legend_title) + tm_borders()

aes.color = c(borders = "red")
aes.color.all = tmap_options()$aes.color
aes.color.all[names(aes.color)] = aes.color

c1 = map_nza + tm_layout(aes.color = aes.color.all) 
c2 = map_nza + tm_layout(attr.color = "red")
c3 = map_nza + tm_layout(sepia.intensity = 0.9)
c4 = map_nza + tm_layout(saturation = 0.1)

tmap_arrange(c1, c2, c3, c4, nrow = 1)
```

**tmap*은 레이아웃과 색상에 대한 낮은 수준의 제어 외에도 'tm_style() 기능(패키지의 'style'의 두 번째 의미)을 사용하여 높은 수준의 스타일을 제공합니다.
'tm_style'("코발트")과 같은 일부 스타일은 맵을 스타일화하지만, 'tm_style("회색")과 같은 다른 스타일은 아래의 코드를 사용하여 생성된 그림 \@ref(그림:tmstyles)와 같이 더 미묘한 변화를 일으킨다.R'):

```{r}
# ggplot의 theme 같은 개념
# 자주 사용함
map_nza + tm_style("bw")
map_nza + tm_style("classic")
map_nza + tm_style("cobalt")
map_nza + tm_style("col_blind")

# tmap_style_catalogue()
```


```{block2 styles, type='rmdnote'}
미리 정의된 스타일의 미리보기는 'tmap_style_catalogue()'를 실행하여 생성할 수 있습니다.
이렇게 하면 9개의 이미지가 포함된 'tmap_style_previews'라는 폴더가 생성됩니다.
tm_style_albatross.png에서 tm_style_white.png에 이르는 각 이미지에는 그에 상응하는 스타일로 세계의 단면도가 표시된다.
참고: 'tmap_style_catalogue()'를 실행하는 데 시간이 걸립니다.
```

### 단면도
'작은 배수'라고도 불리는 면상 지도는 많은 지도들이 나란히 배열되어 있으며, 때로는 수직으로 쌓이기도 한다[@meulemans_small_2017].
측면은 시간과 같은 다른 변수에 대해 공간 관계가 어떻게 변화하는지 시각화할 수 있게 한다.
예를 들어, 정착지의 인구 변화는 특정 시점에 인구를 나타내는 각 패널이 있는 단면도로 나타낼 수 있다.
시간 차원은 색과 같은 다른 *미적*을 통해 표현될 수 있다.
그러나 이것은 여러 겹치는 점들을 포함하기 때문에 지도를 어지럽힐 위험이 있다.

일반적으로 단면 지도의 모든 개별 면은 속성 데이터의 각 열에 대해 한 번씩 여러 번 반복되는 동일한 형상 데이터를 포함한다.
그러나, 패싯은 또한 시간에 따른 점 패턴의 진화와 같은 변화하는 기하학적 구조를 나타낼 수 있다.

```{r}
urb_1970_2030 = urban_agglomerations %>% 
  filter(year %in% c(1970, 1990, 2010, 2030))

urb_1970_2030$geometry # 인구정보를 담고 있는 point 데이터 #

tm_shape(world) +
  tm_polygons() +
  tm_shape(urb_1970_2030) +
  tm_symbols(col = "black", border.col = "white", size = "population_millions") +
  tm_facets(by = "year", nrow = 2, free.coords = FALSE)
```

## 2. 애니메이션 지도

섹션 \@ref(faceted-maps)에 설명된 단면 지도는 변수의 공간 분포가 시간에 따라 어떻게 변화하는지 보여줄 수 있지만, 이 접근 방식은 단점이 있다.
얼굴이 많으면 작아진다.
게다가, 각각의 면들이 화면이나 페이지에서 물리적으로 분리되어 있다는 것은 면들 사이의 미묘한 차이를 감지하기 어려울 수 있다는 것을 의미한다.

애니메이션 맵은 이러한 문제를 해결합니다.
비록 그들이 디지털 출판물에 의존하지만, 점점 더 많은 콘텐츠가 온라인으로 이동함에 따라 이것은 덜 문제가 되고 있다.
애니메이션 맵은 여전히 종이 보고서를 향상시킬 수 있습니다. 인쇄된 맵의 애니메이션(또는 대화형) 버전이 포함된 웹 페이지에 독서자를 항상 연결하여 실제 상태로 만들 수 있습니다.
R에서 애니메이션을 생성하는 방법은 **ggplot2**를 기반으로 하는 **gganimate**와 같은 애니메이션 패키지를 포함하여 여러 가지가 있습니다(섹션 \@ref(기타 매핑 패키지) 참조).
이 섹션에서는 **tmap*을 사용하여 애니메이션 맵을 만드는 데 초점을 맞춥니다. 구문은 이전 섹션과 접근 방식의 유연성에 익숙하기 때문입니다.

그림 \@ref(그림: 도시 애니메이션)는 애니메이션 맵의 간단한 예입니다.
평면적인 플롯과 달리 여러 맵을 하나의 화면에 짜넣지 않으며 독자가 시간이 지남에 따라 세계에서 가장 인구가 많은 집합체의 공간 분포가 어떻게 진화하는지를 볼 수 있게 한다(애니메이션 버전은 책 홈페이지 참조).



```{r}
m_save = world %>% filter(continent != "Antarctica") %>% 
  tm_shape() + 
  tm_polygons() +
  tm_shape(urban_agglomerations) +
  tm_dots(size = "population_millions",
          title.size = "Population (m)", 
          alpha = 0.5, col = "red") +
  tm_facets(along = "year", free.coords = FALSE)

tmap_animation(tm = m_save, 
               filename = "data/urban-animated.gif", 
               width = 1200, height = 800)

magick::image_read("data/urban-animated.gif")
```

그림 \@ref(그림: 도시 애니메이션)에 표시된 애니메이션 맵은 섹션 \@ref(페이스 맵)에 나와 있는 것과 동일한 **tmap* 기법을 사용하여 만들 수 있다.
그러나 tm_facets()의 인수에는 두 가지 차이점이 있다.

- "long = "year" 대신 "long = "year"를 사용합니다.
- 각 맵 반복에 대한 맵 범위를 유지하는 'free.files = FALSE'입니다.

이러한 추가 인수는 후속 코드 청크에서 입증된다:

```{r}
urb_anim = tm_shape(world) + tm_polygons() + 
  tm_shape(urban_agglomerations) + tm_dots(size = "population_millions") +
  tm_facets(along = "year", free.coords = FALSE)
```

결과 urb_anim은 각 연도에 대한 별도의 지도 집합을 나타낸다.
마지막 단계는 이 둘을 결합하여 결과를 tmap_animation()이 추출된 .gif 파일로 저장하는 것입니다.
다음 명령은 연습 중에 추가할 몇 가지 요소가 누락된 상태에서 그림 \@ref(그림:도시 애니메이션)에 표시된 애니메이션을 생성합니다.

```{r}
tmap_animation(urb_anim, filename = "data/urb_anim.gif", delay = 25)
```

## interactive map (대화형 지도)

```{r 08-mapping-25, eval=FALSE}
tmap_mode("view")
map_nz
```

이제 대화형 모드가 '켜짐'되었으므로 **tmap*으로 생성된 모든 맵이 실행됩니다('tmap_leaflet' 기능을 사용하여 대화형 맵을 만드는 또 다른 방법).
이 대화형 모드의 주목할 만한 특징으로는 아래와 같이 'tm_basemap()'(또는 'tmap_options()'으로 기본 맵을 지정할 수 있는 기능이 있다.

```{r 08-mapping-26, eval=FALSE}
map_nz + tm_basemap(server = "OpenTopoMap")
```

**tmap*의 보기 모드의 인상적이고 거의 알려지지 않은 특징은 단면도에서도 작동한다는 것이다.

이 경우 'tm_facets()'의 'sync' 인수를 사용하여 그림 \@ref(fig:sync)와 같이 확대/축소 및 이동 설정이 동기화된 여러 맵을 생성할 수 있으며, 이 맵은 다음 코드로 생성됩니다.

```{r 08-mapping-27, eval=FALSE}
world_coffee = world %>% left_join(coffee_data, by = "name_long") #name_long이라는 공통된 col로 left_join

tm_shape(world_coffee) + 
  tm_polygons(c("coffee_production_2016", "coffee_production_2017")) + 
  tm_facets(nrow = 1, sync = TRUE)

#sync = FALSE : 왼쪽그래프와 오른쪽 그래프가 독립적으로 움직임
tm_shape(world_coffee) + 
  tm_polygons(c("coffee_production_2016", "coffee_production_2017")) + 
  tm_facets(nrow = 1, sync = FALSE)
```

**tmap*을 동일한 기능으로 다시 플로팅 모드로 전환:

```{r 08-mapping-28}
tmap_mode("plot")
```

**tmap**에 익숙하지 않은 경우 대화형 맵을 만드는 가장 빠른 방법은 **mapview*\index{mapview(package)}일 수 있습니다.

다음의 '원 라이너'는 광범위한 지리적 데이터 형식을 대화식으로 탐색할 수 있는 신뢰할 수 있는 방법입니다.

```{r 08-mapping-29, eval=FALSE}
library(mapview)

mapview::mapview(nz)
```

**mapview*는 구문이 간결하지만 강력합니다. 기본적으로 마우스 위치 정보, 속성 쿼리(팝업을 통한), 축척 막대, 줌 투 레이어 버튼과 같은 일부 표준 GIS 기능을 제공한다.

데이터 세트를 여러 레이어로 '버스트'할 수 있는 기능과 '+'로 여러 레이어를 추가하고 지리적 객체 이름을 추가하는 등 고급 제어 기능을 제공한다. 
또한 인수 'zcol'을 통해 속성의 자동 색칠을 제공한다.

본질적으로 데이터 중심 **리플릿* API\index{로 간주할 수 있다.API}(**leaflet**에 대한 자세한 내용은 아래 참조). 
**mapview*는 항상 공간 객체('sf', 'Spacial*the 'Raster*')를 첫 번째 주장으로 기대하기 때문에, 파이프로 연결된 표현식의 끝에서 잘 작동한다. 

선과 다각형 교차에 **sf**를 사용한 다음 **mapview*(그림 \@ref(그림:mapview2)로 시각화되는 다음 예를 생각해 보십시오.

```{r}
library(mapview)
# 
# plot(franconia[1],reset=FALSE)
# plot(franconia[franconia$district == "Oberfranken", ][1],col="red",add=TRUE)
# plot(trails[1],col="black")
# plot(breweries[1])
# 
# 
# 
# trails %>%
#   st_transform(st_crs(franconia)) %>%
#   st_intersection(franconia[franconia$district == "Oberfranken", ]) %>%
#   st_collection_extract("LINE") %>%
#   mapview(color = "red", lwd = 3, layer.name = "trails") +
#   mapview(franconia, zcol = "district", burst = TRUE) +
#   breweries

```


한 가지 중요한 점은 **mapview* 레이어가 '+' 연산자(**ggplot2** 또는 **tmap**와 유사)를 통해 추가된다는 것입니다. 

이 값은 주 바인딩 연산자가 '%>% 인 파이프된 워크플로우에서 자주 사용되는 [gotcha](https://en.wikipedia.org/wiki/Gotcha_(programming)))입니다.

R을 사용하여 대화형 맵을 만드는 다른 방법이 있습니다.
예를 들어 **googleway** 패키지\index{googleway(패키지)}는 유연하고 확장 가능한 대화형 매핑 인터페이스를 제공합니다.
(자세한 내용은 [구글웨이-비넷(https://cran.r-project.org/web/packages/googleway/vignettes/googleway-vignette.html))] 참조).
같은 저자의 또 다른 접근법은 **[mapdeck](https://github.com/Symbolix)이다.AU/mapdeck)**. Uber의 'Deck.gl' 프레임워크\index{mapdeck(mapdeck)}에 액세스할 수 있습니다.
WebGL을 사용하여 대규모 데이터 세트(최대 수백만 점)를 대화식으로 시각화할 수 있다.
패키지는 패키지를 사용하기 전에 등록해야 하는 Mapbox [access token](https://www.mapbox.com/help/how-access-tokens-work/),)을 사용합니다.

```{block2 08-mapping-31, type='rmdnote'}
다음 블록은 액세스 토큰이 R 환경에 'MAPBOX=your_unique_key'로 저장되어 있다고 가정합니다.
이 패키지는 **uses this* 패키지의 'edit_r_environment()'와 함께 추가할 수 있습니다.
```

**mapdeck*의 고유한 특징은 그림 \@ref(그림:mapdeck)에 나와 있는 대화형 '2.5d' 관점을 제공하는 것이다.
즉, 지도를 이동, 확대/축소 및 회전하고 지도에서 '추출된' 데이터를 볼 수 있습니다.
다음 코드 청크로 생성된 그림 \@ref(fig:mapdeck)는 영국의 도로 교통 충돌을 시각화하며, 막대 높이는 영역당 사상자를 나타낸다.

https://www.mapbox.com/ 들어가서 회원가입 후 토큰 발급

pk.eyJ1Ijoic3BlYXI1MzA2IiwiYSI6ImNremN5Z2FrOTI0ZGgycm45Mzh3dDV6OWQifQ.kXGWHPRjnVAEHgVgLzXn2g

mapbox://styles/spear5306/ckzcyy8fa002014qgwdpqxpyq

```{r 08-mapping-33, eval=FALSE}
library(mapdeck)
set_token(Sys.getenv("pk.eyJ1IjoieWFuZ3JoYTQiLCJhIjoiY2wxb2g5eXhtMTRlYjNjanhkMjJpZ3ZoNSJ9.UEjUYjkYfTztuq0sCcIETg"))
crash_data = read.csv("https://git.io/geocompr-mapdeck")
crash_data = na.omit(crash_data)

ms = mapdeck_style("dark")

mapdeck(style = ms,
        pitch = 45,
        location = c(0, 52),
        zoom = 4,
        token = "pk.eyJ1Ijoic3BlYXI1MzA2IiwiYSI6ImNremN5Z2FrOTI0ZGgycm45Mzh3dDV6OWQifQ.kXGWHPRjnVAEHgVgLzXn2g") %>%
  add_grid(data = crash_data, lat = "lat", lon = "lng", cell_size = 1000,
           elevation_scale = 50, layer_id = "grid_layer",
           colour_range = viridisLite::plasma(6))

mapdeck(pitch = 30,
        location = c(0, 52),
        zoom = 1,
        token = "pk.eyJ1IjoieWFuZ3JoYTQiLCJhIjoiY2wxb2g5eXhtMTRlYjNjanhkMjJpZ3ZoNSJ9.UEjUYjkYfTztuq0sCcIETg",
        style = "mapbox://styles/yangrha4/cl1yi0w0w001d15mumm62fhju") %>%
  add_scatterplot(data = crash_data, 
                  lat = "lat", 
                  lon = "lng",
                  layer_id = "scatter_layer",
                  radius = 10)
```

In the browser you can zoom and drag, in addition to rotating and tilting the map when pressing `Cmd`/`Ctrl`.
Multiple layers can be added with the `%>%` operator, as demonstrated in the [`mapdeck` vignette](https://cran.r-project.org/web/packages/mapdeck/vignettes/mapdeck.html). 

Mapdeck also supports `sf` objects, as can be seen by replacing the `add_grid()` function call in the preceding code chunk with `add_polygon(data = lnd, layer_id = "polygon_layer")`, to add polygons representing London to an interactive tilted map.

```{r 08-mapping-35, eval=FALSE, echo=FALSE}
library(mapdeck)
set_token("pk.eyJ1IjoieWFuZ3JoYTQiLCJhIjoiY2wxb2g5eXhtMTRlYjNjanhkMjJpZ3ZoNSJ9.UEjUYjkYfTztuq0sCcIETg")

mapdeck_tokens()

df = read.csv("https://git.io/geocompr-mapdeck")
ms = mapdeck_style('dark')
mapdeck(style = ms, pitch = 45, location = c(0, 52), zoom = 4) %>%
# add_grid(data = df, lat = "lat", lon = "lng", cell_size = 1000,
#          elevation_scale = 50, layer_id = "grid_layer",
#          colour_range = viridisLite::plasma(5)) %>% 
  add_polygon(data = lnd, 
              layer_id = "polygon_layer",
              fill_opacity = 0.3)
```


```{r 08-mapping-36, eval=FALSE, echo=FALSE}
str(roads)
mapdeck(
  , style = mapdeck_style('dark')
  , location = c(145, -37.8)
  , zoom = 10
  ) %>%
  add_path(
    data = roads
    , stroke_colour = "RIGHT_LOC"
    , layer_id = "path_layer"
    , tooltip = "ROAD_NAME"
    , auto_highlight = TRUE
  )
```

마지막으로 **leaflet*은 R\index{leaflet(package)}에서 가장 성숙하고 널리 사용되는 대화형 매핑 패키지이다.
**vp**는 리플릿 자바스크립트 라이브러리에 대한 비교적 낮은 수준의 인터페이스를 제공하며, 대부분의 주장은 원본 자바스크립트 라이브러리의 문서를 읽으면 이해할 수 있다.

리플릿 맵은 '리플릿()'으로 생성되며, 그 결과는 다른 **리플릿* 함수에 파이프될 수 있는 '리플릿' 맵 개체이다.
이를 통해 그림 \@ref(fig:leaflet)를 생성하는 아래 코드에서 보여지듯이 여러 지도 계층과 제어 설정을 대화식으로 추가할 수 있습니다([rstudio] 참조).github.io/leaflet/](http://rstudio.자세한 내용은 github.io/leaflet/)).

```{r}
pal = colorNumeric("RdYlBu", domain = cycle_hire$nbikes)

leaflet(data = cycle_hire) %>% 
  addProviderTiles(providers$CartoDB.Positron) %>%
  addCircles(col = ~pal(nbikes), opacity = 0.9) %>% 
  addPolygons(data = lnd, fill = FALSE) %>% 
  addLegend(pal = pal, values = ~nbikes) %>% 
  setView(lng = -0.1, 51.5, zoom = 12) %>% 
  addMiniMap()
```

```{r}
# install.packages("mapboxapi")
library(mapboxapi)
mb_access_token("pk.eyJ1IjoieWFuZ3JoYTQiLCJhIjoiY2wxeW15a3FhMGR6NTNqbWtxOHl3NGd4aSJ9.DMRmENm8BWnl1VrzpZkMqw",install = TRUE,overwrite=TRUE)
my_token <- Sys.getenv("MAPBOX_PUBLIC_TOKEN")
leaflet(data = cycle_hire) %>% 
  addCircles(col = ~pal(nbikes), opacity = 0.9) %>% 
  addPolygons(data = lnd, fill = FALSE) %>% 
  addLegend(pal = pal, values = ~nbikes) %>% 
  setView(lng = - 0.1, 51.5, zoom = 12) %>% 
  addMiniMap() %>% 
  addMapboxTiles(style_id = "ckzcz5m8w002814o2coz02sjc", username = "spear5306",access_token = my_token)
```

